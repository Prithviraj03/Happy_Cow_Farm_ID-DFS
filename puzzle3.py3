# Program by Prithviraj Arvind Pawar
# Puzzle assignment 3 Happy Cows Farm


import random
from queue import LifoQueue
import copy
import sys


field = []      
temp = []
stack = LifoQueue()     #Frontier generated by using LifoQueue 
inputFile = sys.argv[1]     #gets 1st argument from command line
outputFile = sys.argv[2]    #gets 2nd argument from command line


class Cow(object):

# reads input file
    with open(inputFile) as f:
        lines = f.readlines()
       
        for i in lines:
            a = list(i.rstrip())
            field.append(a)
   
    size_of_field = int(field[0][0]) #takes out size of farm from input.txt file
    ##print(size_of_field)

#counting number of @'s
    z = "@"
    counter = 0
    for i in range(len(field)):
        counter += field[i].count(z)
    i = 1 




#to find index of Character in this case for "C"
def find(char):
    for i, istr in enumerate(field):
        
        for j,jstr in enumerate(istr):
            try:
                if jstr == char:
                    yield i, j
            except ValueError:
                continue

# to check if the index is outofbounds           
def isValidPos(i, j, n, m):
 
    if (i < 0 or j < 0 or i > n - 1 or j > m - 1):
        return 0
    return 1

# to calculate score of HappyCow Farm
def CountScore(arr, i, j):
    offsets = [[-1,-1],[-1,0],[-1,1],
               [0,-1],        [0, 1],
               [ 1,-1],[1, 0],[1,1]]

    
 # Size of given 2d array
    n = len(arr)
    m = len(arr[0])

    CowScore = 0
    another_cow = False
    pond = False
    haystack = False
    for off in range(0,8):
        
        row = i + offsets[off][0] # 1 + [-1]
        col = j + offsets[off][1]
        
        
        #Check if the index is orthogonal, since we need to find haystack and pond in vertical and horizontal positions
        total = sum(offsets[off])
        
        if total == -1 or total == 1:
            orthogonal = True
        else:
            orthogonal = False
        
        #Check if the index is a valid position or not 
        if (isValidPos(row,col,n,m)):
            if arr[row][col] == 'C':
                another_cow = True
            elif orthogonal:
                if arr[row][col] == '@':
                    haystack = True
                if arr[row][col] == '#':
                    pond = True
   
    if another_cow:
        CowScore -= 3
    if haystack:
        CowScore += 1
        if pond:
           CowScore += 2
    
    return CowScore

# to generate output file
def output_data(lines, filename):
    with open(filename, 'w') as file:
        for item in field:
            for i in range(len(item)):
                file.write("%s" % item[i])
            file.write("\n")
        file.close()


# takes the field map from the input text file
farm_grid = field[1:]

# pops the first element in input text file 
farmSize = field.pop(0)

# generating frontier
def generate_frontier():
    frontier = LifoQueue()
    for i in range(0,int(farmSize[0])):
        for j in range(0,int(farmSize[0])):
            frontier.put([(i,j)])

    #reversing the lifoQueue  
    listLIFO = list(frontier.queue)
    listLIFO.reverse()

    rev_LIFO = LifoQueue()
    #gets it items from the list and generates new LIFO queue
    for items in listLIFO:
        rev_LIFO.put(items) 
    
    #yields the LIFO Queue
    yield rev_LIFO.get()
    #yields the LIFO Queue when queue is not empty
    while not rev_LIFO.empty():
        yield rev_LIFO.get()


#Implements IDFS function for game HappyCow Farm
def idfs(depth, max_depth, action_state, total_score, farm_grid):
    # If we have exceeded the maximum depth, we return False to signal that we did not find a solution
    if depth > max_depth:
        return False, None
    # If the total score is greater than or equal to 7, we have found a solution, so we return True and the final farm grid
    if total_score >= 7:
        return True, farm_grid
    # We initialize variables to keep track of whether we have found a solution and the final farm grid
    found = False
    result = None
    # We iterate through all the squares on the farm grid to find the next valid move
    for i in range(int(farmSize[0])):
        for j in range(int(farmSize[0])):
            if (i,j) > action_state[-1] and farm_grid[i][j] == '.':
                # We create a copy of the farm grid and the current action state to simulate the next move
                temp_grid = copy.deepcopy(farm_grid)
                temp_action = action_state[:]
                temp_action.append((i,j))
                temp_grid[i][j] = 'C'
                temp_score = total_score + CountScore(temp_grid, i, j)
                # We recursively call the IDDFS function with the updated state and score
                found, result = idfs(depth+1, max_depth, temp_action, temp_score, temp_grid)
                # If we have found a solution, we return True and the final farm 
                if found:
                    return True, result
    # If we have not found a solution, we return False and None
    return found, result


stack = generate_frontier() #creates frontier

max_depth = 25  #max depth of frontier

# Iterate over the range of maximum search depth
for depth in range(max_depth):

     # Generate all possible action states for the given farm size
    for action_state in generate_frontier():
        # Create a deep copy of the original farm grid
        temp = copy.deepcopy(farm_grid)

        # Update the temporary grid with the current state of the action
        for i in action_state:
            row = i[0]
            col = i[1]
            if temp[row][col] == ".":
                temp[row][col] = "C"
        # Calculate the total score for the current action state
        total_score = 0
        for i in action_state:
            row = i[0]
            col = i[1]
            total_score += CountScore(temp, row, col)
        # Apply iterative deepening depth-first search with the current state
        found, result = idfs(1, depth, action_state, total_score, temp)
        # If a solution is found, store it in the "field" variable and print the current frontier
        if found:
            field = result
            print(f"The frontier is {action_state}")
            break
    if found:
        break



#Find the index for all the Cows placed in the farm
matches = [match for match in find('C')]

#Calculate Score of all the cows
Total_Cow_Score = 0
for i,j in matches:
    Total_Cow_Score += CountScore(field, i, j)

#Adds total score to array
field.append([str(Total_Cow_Score)])

#Adds farm size back to array
field.insert(0, farmSize)

#creates outputfile
output_data(field,outputFile)




